{
	"info": {
		"_postman_id": "293a77a1-0c67-4d46-9946-33cbd7b370dd",
		"name": "06 - Advanced Techniques",
		"description": "# 06 - Advanced Techniques\n\n## Overview\n\nThis collection showcases advanced API testing methodologies that go beyond basic CRUD operations. It demonstrates professional-level testing techniques including JSON schema validation, performance benchmarking, and conditional test logic. These techniques are essential for robust API testing in production environments and demonstrate expertise in quality assurance automation.\n\n## API Used\n\n- **Base URL**: [https://fakestoreapi.com](https://fakestoreapi.com)\n    \n- **Documentation**: [https://fakestoreapi.com/docs](https://fakestoreapi.com/docs)\n    \n- **Endpoint Focus**: /products\n    \n- **No Authentication Required**: Public testing API\n    \n\n## What Makes These Techniques \"Advanced\"?\n\nThese techniques demonstrate:\n\n- **Contract Testing**: Validating API responses match expected schemas\n    \n- **Performance Monitoring**: Ensuring SLAs are met\n    \n- **Intelligent Validation**: Adapting tests based on response conditions\n    \n- **Industry Standards**: Using professional testing libraries (AJV)\n    \n- **Production-Ready**: Techniques used in real-world testing scenarios\n    \n\n## Features Demonstrated\n\n- ‚úÖ JSON Schema validation with AJV library\n    \n- ‚úÖ Performance threshold testing\n    \n- ‚úÖ Response time benchmarking\n    \n- ‚úÖ Conditional validation logic\n    \n- ‚úÖ Dynamic test execution\n    \n- ‚úÖ Contract testing principles\n    \n- ‚úÖ SLA validation\n    \n- ‚úÖ Advanced assertion techniques\n    \n\n## Collection Contents\n\n### 1\\. Schema Validation\n\n**Purpose**: Validate API response structure matches defined contract\n\n#### What is Schema Validation?\n\nSchema validation ensures the API returns data in the expected format, type, and structure. It's a form of **contract testing** that catches breaking changes early.\n\n#### Implementation Details\n\n``` javascript\n// Define expected schema\nconst productSchema = {\n    type: \"object\",\n    required: [\"id\", \"title\", \"price\", \"description\", \"category\", \"image\", \"rating\"],\n    properties: {\n        id: { type: \"number\" },\n        title: { type: \"string\" },\n        price: { type: \"number\" },\n        description: { type: \"string\" },\n        category: { type: \"string\" },\n        image: { type: \"string\" },\n        rating: {\n            type: \"object\",\n            required: [\"rate\", \"count\"],\n            properties: {\n                rate: { type: \"number\" },\n                count: { type: \"number\" }\n            }\n        }\n    }\n};\n\n ```\n\n#### AJV Library Usage\n\n``` javascript\nconst Ajv = require('ajv'); // Import JSON validator\nconst ajv = new Ajv({ logger: console }); // Create validator instance\nconst validate = ajv.compile(productSchema); // Compile schema\nconst valid = validate(response); // Validate response\n\n ```\n\n#### Tests Performed\n\n- ‚úÖ Status code validation (200)\n    \n- ‚úÖ Response is an object\n    \n- ‚úÖ Schema validation with AJV\n    \n- ‚úÖ All required fields present\n    \n- ‚úÖ All data types correct (number, string, object)\n    \n- ‚úÖ Nested object validation (rating.rate, rating.count)\n    \n- ‚úÖ Error logging for schema violations\n    \n\n**Benefits**:\n\n- Catches API contract violations\n    \n- Validates data types automatically\n    \n- Ensures required fields are present\n    \n- Documents expected API structure\n    \n- Prevents breaking changes\n    \n\n### 2\\. Performance Testing - GET\n\n**Purpose**: Validate GET request performance meets SLA requirements\n\n#### Performance Requirements\n\n- **Target**: Response time < 200ms\n    \n- **Method**: GET\n    \n- **Endpoint**: /products/1\n    \n\n#### Tests Performed\n\n- ‚úÖ Status code validation (200)\n    \n- ‚úÖ Response time < 200ms threshold\n    \n- ‚úÖ Performance benchmark validation\n    \n\n**Why 200ms?**\n\n- Industry standard for read operations\n    \n- Good user experience threshold\n    \n- Acceptable for real-time applications\n    \n- CDN/cache-optimized endpoints\n    \n\n#### Implementation\n\n``` javascript\npm.test(\"Response time is less than 500ms\", function () {\n    pm.expect(response.responseTime).to.be.below(500);\n});\n\n ```\n\n**Real-World Application**:\n\n- API SLA monitoring\n    \n- Performance regression detection\n    \n- Response time tracking\n    \n- User experience validation\n    \n\n### 3\\. Performance Testing - POST\n\n**Purpose**: Validate POST request performance for write operations\n\n#### Performance Requirements\n\n- **Target**: Response time < 500ms\n    \n- **Method**: POST\n    \n- **Endpoint**: /products\n    \n- **Operation**: Create new product\n    \n\n#### Tests Performed\n\n- ‚úÖ Status code validation (201 Created)\n    \n- ‚úÖ Response time < 500ms threshold\n    \n- ‚úÖ Write operation performance\n    \n\n**Why 500ms?**\n\n- Write operations take longer than reads\n    \n- Includes database/storage operations\n    \n- Acceptable for non-real-time operations\n    \n- Allows for server processing time\n    \n\n#### Implementation\n\n``` javascript\npm.test(\"Response time is less than 500ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(500);\n});\n\n ```\n\n**Performance Tiers**:\n\n- **Excellent**: < 200ms\n    \n- **Good**: 200-500ms\n    \n- **Acceptable**: 500-1000ms\n    \n- **Poor**: > 1000ms\n    \n\n### 4\\. Conditional Validation\n\n**Purpose**: Adapt test validation based on response status codes\n\n#### What is Conditional Validation?\n\nTests that change behavior based on the API response, allowing flexible validation for different scenarios.\n\n#### Implementation\n\n``` javascript\npm.test(\"Validate response based on status code\", function() {\n    const responseCode = pm.response.code;\n    const json = pm.response.json();\n    if (responseCode === 201) {\n        console.log(\"Status 201 - Validating success response\");\n        pm.expect(json).to.have.property('id');\n        pm.expect(json).to.have.property('title');\n    } else if (responseCode === 200) {\n        console.log(\"Status 200 - Validating success response\");\n        pm.expect(json).to.have.property('id');\n        pm.expect(json).to.have.property('title');\n    }\n});\n\n ```\n\n#### Tests Performed\n\n- ‚úÖ Dynamic validation based on status code\n    \n- ‚úÖ Different assertions for 200 vs 201\n    \n- ‚úÖ Response time validation\n    \n- ‚úÖ Flexible test logic\n    \n- ‚úÖ Console logging for debugging\n    \n\n**Use Cases**:\n\n- APIs with multiple success responses\n    \n- Error handling validation\n    \n- Graceful degradation testing\n    \n- Backward compatibility validation\n    \n\n## Advanced Testing Concepts\n\n### JSON Schema Validation\n\n#### Why Schema Validation Matters\n\n1. **Contract Testing**: Ensures API adheres to documented contract\n    \n2. **Breaking Change Detection**: Catches structure changes immediately\n    \n3. **Type Safety**: Validates data types match expectations\n    \n4. **Required Fields**: Ensures critical fields always present\n    \n5. **Documentation**: Schema serves as living documentation\n    \n\n#### Schema Benefits\n\n``` javascript\n// Without schema validation\npm.test(\"Has title\", function() {\n    pm.expect(response.title).to.exist;\n});\n// With schema validation - catches ALL issues at once\npm.test(\"Schema valid\", function() {\n    const valid = validate(response);\n    pm.expect(valid).to.be.true;\n});\n\n ```\n\n#### Common Schema Patterns\n\n**Basic Types**:\n\n``` javascript\n{ type: \"string\" }\n{ type: \"number\" }\n{ type: \"boolean\" }\n{ type: \"object\" }\n{ type: \"array\" }\n\n ```\n\n**Required Fields**:\n\n``` javascript\n{\n    type: \"object\",\n    required: [\"id\", \"name\", \"email\"]\n}\n\n ```\n\n**Nested Objects**:\n\n``` javascript\n{\n    type: \"object\",\n    properties: {\n        user: {\n            type: \"object\",\n            properties: {\n                name: { type: \"string\" },\n                age: { type: \"number\" }\n            }\n        }\n    }\n}\n\n ```\n\n**Arrays with Item Schema**:\n\n``` javascript\n{\n    type: \"array\",\n    items: {\n        type: \"object\",\n        properties: {\n            id: { type: \"number\" }\n        }\n    }\n}\n\n ```\n\n### Performance Testing Best Practices\n\n#### Setting Realistic Thresholds\n\n1. **Measure First**: Run tests to get baseline\n    \n2. **Set Targets**: Define acceptable performance\n    \n3. **Add Buffer**: Account for network variability\n    \n4. **Monitor Trends**: Track performance over time\n    \n\n#### Performance Test Strategy\n\n``` javascript\n// Basic threshold\npm.test(\"Fast response\", function() {\n    pm.expect(pm.response.responseTime).to.be.below(500);\n});\n// Tiered validation\npm.test(\"Performance tier\", function() {\n    const time = pm.response.responseTime;\n    if (time < 100) {\n        console.log(\"‚ö° Excellent performance\");\n    } else if (time < 500) {\n        console.log(\"‚úì Good performance\");\n    } else if (time < 1000) {\n        console.log(\"‚ö† Acceptable performance\");\n    } else {\n        console.log(\"‚ùå Poor performance\");\n        pm.expect.fail(`Response too slow: ${time}ms`);\n    }\n});\n\n ```\n\n#### Tracking Performance Metrics\n\n``` javascript\n// Store response times for analysis\nlet times = pm.collectionVariables.get(\"response_times\") || [];\ntimes.push(pm.response.responseTime);\npm.collectionVariables.set(\"response_times\", times);\n// Calculate statistics\nconst avg = times.reduce((a, b) => a + b, 0) / times.length;\nconst min = Math.min(...times);\nconst max = Math.max(...times);\nconsole.log(`Avg: ${avg.toFixed(2)}ms | Min: ${min}ms | Max: ${max}ms`);\n\n ```\n\n### Conditional Testing Patterns\n\n#### Pattern 1: Status Code Based\n\n``` javascript\nconst code = pm.response.code;\nif (code === 200) {\n    // Validate successful retrieval\n} else if (code === 201) {\n    // Validate successful creation\n} else if (code === 404) {\n    // Validate error message\n} else {\n    pm.expect.fail(`Unexpected status: ${code}`);\n}\n\n ```\n\n#### Pattern 2: Response Content Based\n\n``` javascript\nconst json = pm.response.json();\nif (json.status === \"active\") {\n    // Validate active record fields\n} else if (json.status === \"inactive\") {\n    // Validate inactive record fields\n}\n\n ```\n\n#### Pattern 3: Environment Based\n\n``` javascript\nconst env = pm.environment.get(\"environment\");\nif (env === \"production\") {\n    // Stricter validation for production\n    pm.expect(pm.response.responseTime).to.be.below(200);\n} else {\n    // More lenient for dev/test\n    pm.expect(pm.response.responseTime).to.be.below(1000);\n}\n\n ```\n\n## Test Coverage\n\n- ‚úÖ JSON schema compliance\n    \n- ‚úÖ Data type validation\n    \n- ‚úÖ Required fields validation\n    \n- ‚úÖ Nested object validation\n    \n- ‚úÖ Performance thresholds (GET/POST)\n    \n- ‚úÖ Response time monitoring\n    \n- ‚úÖ Conditional logic testing\n    \n- ‚úÖ Dynamic validation\n    \n- ‚úÖ Error logging\n    \n- ‚úÖ SLA compliance\n    \n\n## Variables Used\n\n| Variable | Purpose | Scope |\n| --- | --- | --- |\n| `base_url` | API base URL | Collection |\n\n## How to Run\n\n### Setup\n\n```\nbase_url = https://fakestoreapi.com\n\n ```\n\n### Using Postman Collection Runner\n\n**Full Collection**:\n\n1. Run all requests to see different techniques\n    \n2. Review test results for each pattern\n    \n3. Check console for detailed logging\n    \n\n**Individual Requests**:\n\n- Test schema validation independently\n    \n- Compare GET vs POST performance\n    \n- Experiment with conditional logic\n    \n\n### Using Newman CLI\n\n**Basic Execution**:\n\n``` bash\nnewman run \"06-Advanced-Techniques.postman_collection.json\" \\\n  --reporters cli,htmlextra \\\n  --reporter-htmlextra-export ./reports/advanced-report.html\n\n ```\n\n**Performance Monitoring**:\n\n``` bash\n# Run multiple iterations to track performance\nnewman run \"06-Advanced-Techniques.postman_collection.json\" \\\n  --iteration-count 10 \\\n  --delay-request 100\n\n ```\n\n**With Environment Variables**:\n\n``` bash\nnewman run collection.json \\\n  --environment production.json \\\n  --reporters cli,json \\\n  --reporter-json-export performance-data.json\n\n ```\n\n## Real-World Applications\n\n### 1\\. Contract Testing in CI/CD\n\n``` yaml\n# GitHub Actions example\n- name: Validate API Contract\n  run: newman run 06-advanced-techniques.json --folder \"Schema Validation\"\n\n ```\n\n### 2\\. Performance Regression Detection\n\n``` javascript\n// Fail build if performance degrades\nconst threshold = 500;\nconst current = pm.response.responseTime;\nconst baseline = pm.environment.get(\"baseline_time\");\nif (current > baseline * 1.2) { // 20% slower\n    pm.expect.fail(`Performance regression: ${current}ms vs ${baseline}ms`);\n}\n\n ```\n\n### 3\\. SLA Monitoring\n\n``` javascript\n// Track SLA compliance\nconst sla_met = pm.response.responseTime < 200;\npm.collectionVariables.set(\"sla_failures\", \n    (pm.collectionVariables.get(\"sla_failures\") || 0) + (sla_met ? 0 : 1)\n);\n\n ```\n\n### 4\\. API Documentation Validation\n\n``` javascript\n// Ensure API matches OpenAPI/Swagger spec\nconst swaggerSchema = pm.environment.get(\"swagger_product_schema\");\nconst valid = validate(pm.response.json(), swaggerSchema);\npm.expect(valid).to.be.true;\n\n ```\n\n## Extending These Techniques\n\n### Add Response Size Validation\n\n``` javascript\npm.test(\"Response size is reasonable\", function() {\n    const size = pm.response.responseSize;\n    pm.expect(size).to.be.below(1000000); // < 1MB\n    console.log(`Response size: ${(size / 1024).toFixed(2)} KB`);\n});\n\n ```\n\n### Add Header Validation\n\n``` javascript\npm.test(\"Security headers present\", function() {\n    pm.expect(pm.response.headers.get(\"Content-Type\")).to.include(\"application/json\");\n    pm.expect(pm.response.headers.get(\"X-Frame-Options\")).to.exist;\n});\n\n ```\n\n### Add Advanced Schema Patterns\n\n``` javascript\n// Enum validation\n{\n    category: {\n        type: \"string\",\n        enum: [\"electronics\", \"jewelery\", \"men's clothing\", \"women's clothing\"]\n    }\n}\n// Pattern matching\n{\n    email: {\n        type: \"string\",\n        pattern: \"^[\\\\w-\\\\.]+@([\\\\w-]+\\\\.)+[\\\\w-]{2,}$\"\n    }\n}\n// Minimum/Maximum values\n{\n    price: {\n        type: \"number\",\n        minimum: 0,\n        maximum: 10000\n    }\n}\n\n ```\n\n### Add Performance Percentiles\n\n``` javascript\n// Track 95th percentile response time\nlet times = JSON.parse(pm.collectionVariables.get(\"times\") || \"[]\");\ntimes.push(pm.response.responseTime);\ntimes.sort((a, b) => a - b);\nconst p95Index = Math.floor(times.length * 0.95);\nconst p95 = times[p95Index];\nconsole.log(`P95 Response Time: ${p95}ms`);\npm.collectionVariables.set(\"times\", JSON.stringify(times));\n\n ```\n\n## Prerequisites\n\n- Postman Desktop App or Postman Web (AJV library included)\n    \n- Internet connection\n    \n- No API key required\n    \n- Understanding of JSON Schema (helpful but not required)\n    \n\n## Skills Showcased\n\n- JSON Schema validation\n    \n- AJV library usage\n    \n- Contract testing principles\n    \n- Performance benchmarking\n    \n- Response time monitoring\n    \n- SLA validation\n    \n- Conditional test logic\n    \n- Dynamic test execution\n    \n- Advanced JavaScript in tests\n    \n- Error handling and logging\n    \n- Professional testing patterns\n    \n- Production-ready testing techniques\n    \n- API quality assurance\n    \n- Non-functional testing\n    \n\n## Comparison: Basic vs Advanced Testing\n\n### Basic Testing\n\n``` javascript\npm.test(\"Has id\", function() {\n    pm.expect(json.id).to.exist;\n});\npm.test(\"Has title\", function() {\n    pm.expect(json.title).to.exist;\n});\n// ... 10 more similar tests\n\n ```\n\n### Advanced Testing\n\n``` javascript\n// One schema validation replaces 10+ individual tests\npm.test(\"Schema valid\", function() {\n    const valid = validate(json);\n    pm.expect(valid).to.be.true;\n});\n\n ```\n\n## Common Pitfalls & Solutions\n\n### Pitfall 1: Overly Strict Schemas\n\n**Problem**: Schema too restrictive, fails on valid variations  \n**Solution**: Use `additionalProperties: true` for flexible objects\n\n### Pitfall 2: Unrealistic Performance Thresholds\n\n**Problem**: Tests fail due to network latency, not API performance  \n**Solution**: Set environment-specific thresholds, add buffer time\n\n### Pitfall 3: Missing Conditional Edge Cases\n\n**Problem**: Tests don't cover all possible response codes  \n**Solution**: Always include `else` clause with failure message\n\n### Pitfall 4: Schema Not Maintained\n\n**Problem**: Schema outdated after API changes  \n**Solution**: Version schemas, update with API changes, store in repo\n\n## Notes\n\n- ‚úÖ AJV library is built into Postman\n    \n- ‚úÖ Schema validation is industry standard\n    \n- ‚úÖ Performance thresholds should match your SLAs\n    \n- ‚úÖ Conditional validation enables flexible testing\n    \n- üìù These techniques are production-ready\n    \n- üìù Used in professional testing environments\n    \n- üìù Essential for API quality assurance\n    \n- üìù Demonstrates advanced testing expertise\n    \n\n## Summary\n\nThis collection showcases professional-level API testing techniques that go beyond basic validation. Schema validation ensures API contracts are maintained, performance testing validates SLAs, and conditional validation enables intelligent test execution. These techniques are essential for robust, production-ready API testing and demonstrate expertise in quality assurance automation.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "48982578",
		"_collection_link": "https://www.postman.com/patmcdaniel37-5264329/workspace/api-testing/collection/48982578-293a77a1-0c67-4d46-9946-33cbd7b370dd?action=share&source=collection_link&creator=48982578"
	},
	"item": [
		{
			"name": "Schema Validation",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const json = pm.response.json();",
							"const productSchema = {",
							"    type: \"object\",",
							"    required: [\"id\", \"title\", \"price\", \"description\", \"category\", \"image\", \"rating\"],",
							"    properties: {",
							"        id: { type: \"number\" },",
							"        title: { type: \"string\" },",
							"        price: { type: \"number\" },",
							"        description: { type: \"string\" },",
							"        category: { type: \"string\" },",
							"        image: { type: \"string\" },",
							"        rating: {",
							"            type: \"object\",",
							"            required: [\"rate\", \"count\"],",
							"            properties: {",
							"                rate: { type: \"number\" },",
							"                count: { type: \"number\" }",
							"            }",
							"        }",
							"    }",
							"};",
							"const Ajv = require('ajv'); //Imports the AJV library(Another JSON Validator)",
							"const ajv = new Ajv({ logger: console });//Creates an instance of the AJV validator, log to console",
							"const validate = ajv.compile(productSchema);//Compiles schema into a validation function ",
							"",
							"//validate response code",
							"pm.test(\"validate response code is 200\", function(){",
							"    pm.response.to.have.status(200);",
							"});",
							"",
							"//validate response is an object",
							"pm.test(\"Response is an object\", function () {",
							"    pm.expect(pm.response.json()).to.be.an('object');",
							"});",
							"",
							"//validates schema is correct",
							"pm.test(\"Validate schema is correct\", function () {",
							"    // const Ajv = require('ajv');",
							"    // const ajv = new Ajv({ logger: console });",
							"    // const validate = ajv.compile(productSchema);",
							"    const valid = validate(json);",
							"    ",
							"    if (!valid) {",
							"        console.log(\"Schema validation errors:\", validate.errors);",
							"    }",
							"    ",
							"    pm.expect(valid).to.be.true;",
							"});",
							"",
							"//validate each record has id, title, price, description, category, image",
							"pm.test(\"Each record has the correct fields\", function(){",
							"    pm.expect(json).to.have.property('id');",
							"    pm.expect(json).to.have.property('title');",
							"    pm.expect(json).to.have.property('price');",
							"    pm.expect(json.price).to.be.a('number');",
							"    pm.expect(json).to.have.property('description');",
							"    pm.expect(json).to.have.property('category');",
							"    pm.expect(json).to.have.property('image');",
							"    pm.expect(json).to.have.property('rating');",
							"    pm.expect(json.rating).to.have.property('rate');",
							"    pm.expect(json.rating).to.have.property('count');",
							"});",
							"",
							"pm.test(\"Validate data types correct\", function () {",
							"    pm.expect(json.id).to.be.a('number');",
							"    pm.expect(json.title).to.be.a('string');",
							"    pm.expect(json.price).to.be.a('number');",
							"    pm.expect(json.description).to.be.a('string');",
							"    pm.expect(json.category).to.be.a('string');",
							"    pm.expect(json.image).to.be.a('string');",
							"    pm.expect(json.rating).to.be.an('object');",
							"    pm.expect(json.rating.rate).to.be.a('number');",
							"    pm.expect(json.rating.count).to.be.a('number');",
							"});",
							""
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{base_url}}/products/1",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"products",
						"1"
					]
				},
				"description": "#### tion?\n\nSchema validation ensures the API returns data in the expected format, type, and structure. It's a form of **contract testing** that catches breaking changes early.\n\n#### Implementation Details\n\n``` javascript\n// Define expected schema\nconst productSchema = {\n    type: \"object\",\n    required: [\"id\", \"title\", \"price\", \"description\", \"category\", \"image\", \"rating\"],\n    properties: {\n        id: { type: \"number\" },\n        title: { type: \"string\" },\n        price: { type: \"number\" },\n        description: { type: \"string\" },\n        category: { type: \"string\" },\n        image: { type: \"string\" },\n        rating: {\n            type: \"object\",\n            required: [\"rate\", \"count\"],\n            properties: {\n                rate: { type: \"number\" },\n                count: { type: \"number\" }\n            }\n        }\n    }\n};\n\n ```\n\n#### AJV Library Usage\n\n``` javascript\nconst Ajv = require('ajv'); // Import JSON validator\nconst ajv = new Ajv({ logger: console }); // Create validator instance\nconst validate = ajv.compile(productSchema); // Compile schema\nconst valid = validate(response); // Validate response\n\n ```\n\n#### Tests Performed\n\n- ‚úÖ Status code validation (200)\n    \n- ‚úÖ Response is an object\n    \n- ‚úÖ Schema validation with AJV\n    \n- ‚úÖ All required fields present\n    \n- ‚úÖ All data types correct (number, string, object)\n    \n- ‚úÖ Nested object validation (rating.rate, rating.count)\n    \n- ‚úÖ Error logging for schema violations\n    \n\n**Benefits**:\n\n- Catches API contract violations\n    \n- Validates data types automatically\n    \n- Ensures required fields are present\n    \n- Documents expected API structure\n    \n- Prevents breaking changes"
			},
			"response": []
		},
		{
			"name": "Performance Testing - Get",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const response = pm.response;",
							"",
							"//validate response code",
							"pm.test(\"validate response code is 200\", function(){",
							"    response.to.have.status(200);",
							"});",
							"",
							"//validate response time is less than 200ms",
							"pm.test(\"Response time is less than 200ms\", function () {",
							"    pm.expect(response.responseTime).to.be.below(200);",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "GET",
				"header": [],
				"url": {
					"raw": "{{base_url}}/products/1",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"products",
						"1"
					]
				},
				"description": "### 2\\. Performance Testing - GET\n\n**Purpose**: Validate GET request performance meets SLA requirements\n\n#### Performance Requirements\n\n- **Target**: Response time < 200ms\n    \n- **Method**: GET\n    \n- **Endpoint**: /products/1\n    \n\n#### Tests Performed\n\n- ‚úÖ Status code validation (200)\n    \n- ‚úÖ Response time < 200ms threshold\n    \n- ‚úÖ Performance benchmark validation\n    \n\n**Why 200ms?**\n\n- Industry standard for read operations\n    \n- Good user experience threshold\n    \n- Acceptable for real-time applications\n    \n- CDN/cache-optimized endpoints\n    \n\n#### Implementation\n\n``` javascript\npm.test(\"Response time is less than 200ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(200);\n});\n\n ```\n\n**Real-World Application**:\n\n- API SLA monitoring\n    \n- Performance regression detection\n    \n- Response time tracking\n    \n- User experience validation"
			},
			"response": []
		},
		{
			"name": "Performance Testing - Post",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const response = pm.response;",
							"",
							"//validate response code",
							"pm.test(\"validate response code is 201\", function(){",
							"    response.to.have.status(201);",
							"});",
							"",
							"//validate response time is less than 500ms",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(response.responseTime).to.be.below(500);",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"title\" : \"USB-C Flash Drive 99TB\",\n    \"price\" : \"99.99\", \n    \"description\" : \"USB-C Flash Drive 99TB\",\n    \"image\" : \"https://fakestoreapi.com/img/123ABC_99TB.png\", \n    \"category\" : \"electronics\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{base_url}}/products",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"products"
					]
				},
				"description": "### 3\\. Performance Testing - POST\n\n**Purpose**: Validate POST request performance for write operations\n\n#### Performance Requirements\n\n- **Target**: Response time < 500ms\n    \n- **Method**: POST\n    \n- **Endpoint**: /products\n    \n- **Operation**: Create new product\n    \n\n#### Tests Performed\n\n- ‚úÖ Status code validation (201 Created)\n    \n- ‚úÖ Response time < 500ms threshold\n    \n- ‚úÖ Write operation performance\n    \n\n**Why 500ms?**\n\n- Write operations take longer than reads\n    \n- Includes database/storage operations\n    \n- Acceptable for non-real-time operations\n    \n- Allows for server processing time\n    \n\n#### Implementation\n\n``` javascript\npm.test(\"Response time is less than 500ms\", function () {\n    pm.expect(pm.response.responseTime).to.be.below(500);\n});\n\n ```\n\n**Performance Tiers**:\n\n- **Excellent**: < 200ms\n    \n- **Good**: 200-500ms\n    \n- **Acceptable**: 500-1000ms\n    \n- **Poor**: > 1000ms"
			},
			"response": []
		},
		{
			"name": "Conditional Validation",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const response = pm.response;",
							"const json = pm.response.json();",
							"",
							"//validate response based on code",
							"pm.test(\"Validate response based on status code\", function(){",
							"    if (response.code === 201) {",
							"    console.log(\"Status 201 - Validating success response\");",
							"    pm.expect(json).to.have.property('id');",
							"    pm.expect(json).to.have.property('title');",
							"    } else if (response.code === 200) {",
							"    console.log(\"Status 200 - Validating success response\");",
							"    pm.expect(json).to.have.property('id');",
							"    pm.expect(json).to.have.property('title');",
							"    }",
							"});",
							"",
							"//validate response time is less than 500ms",
							"pm.test(\"Response time is less than 500ms\", function () {",
							"    pm.expect(response.responseTime).to.be.below(500);",
							"});"
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				},
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							""
						],
						"type": "text/javascript",
						"packages": {},
						"requests": {}
					}
				}
			],
			"request": {
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\n    \"title\" : \"USB-C Flash Drive 99TB\",\n    \"price\" : \"99.99\", \n    \"description\" : \"USB-C Flash Drive 99TB\",\n    \"image\" : \"https://fakestoreapi.com/img/123ABC_99TB.png\", \n    \"category\" : \"electronics\"\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "{{base_url}}/products",
					"host": [
						"{{base_url}}"
					],
					"path": [
						"products"
					]
				},
				"description": "### 4\\. Conditional Validation\n\n**Purpose**: Adapt test validation based on response status codes\n\n#### What is Conditional Validation?\n\nTests that change behavior based on the API response, allowing flexible validation for different scenarios.\n\n#### Implementation\n\n``` javascript\npm.test(\"Validate response based on status code\", function() {\n    const responseCode = pm.response.code;\n    const json = pm.response.json();\n    if (responseCode === 201) {\n        console.log(\"Status 201 - Validating success response\");\n        pm.expect(json).to.have.property('id');\n        pm.expect(json).to.have.property('title');\n    } else if (responseCode === 200) {\n        console.log(\"Status 200 - Validating success response\");\n        pm.expect(json).to.have.property('id');\n        pm.expect(json).to.have.property('title');\n    }\n});\n\n ```\n\n#### Tests Performed\n\n- ‚úÖ Dynamic validation based on status code\n    \n- ‚úÖ Different assertions for 200 vs 201\n    \n- ‚úÖ Response time validation\n    \n- ‚úÖ Flexible test logic\n    \n- ‚úÖ Console logging for debugging\n    \n\n**Use Cases**:\n\n- APIs with multiple success responses\n    \n- Error handling validation\n    \n- Graceful degradation testing\n    \n- Backward compatibility validation"
			},
			"response": []
		}
	],
	"variable": [
		{
			"key": "base_url",
			"value": "",
			"type": "default"
		}
	]
}